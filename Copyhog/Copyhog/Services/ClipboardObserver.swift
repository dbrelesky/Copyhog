import AppKit
import Foundation

@MainActor
final class ClipboardObserver {

    private var timer: Timer?
    private var lastChangeCount: Int
    private let pasteboard = NSPasteboard.general
    private var isOwnWrite = false
    private let imageStore: ImageStore
    var exclusionManager: ExclusionManager?

    /// Pasteboard types that password managers use to mark sensitive content.
    private static let sensitiveTypes: Set<NSPasteboard.PasteboardType> = [
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType"),
        NSPasteboard.PasteboardType("com.agilebits.onepassword"),
    ]

    private static let redactedPlaceholder = "••••••••••"

    /// Global keyboard monitor for Cmd+C — captures frontmost app at exact copy moment.
    private var keyMonitor: Any?

    /// The bundle ID of the app that was frontmost when Cmd+C was last pressed.
    private var lastCmdCApp: String?
    /// Timestamp of the last Cmd+C press.
    private var lastCmdCTimestamp: Date?

    init(imageStore: ImageStore) {
        self.imageStore = imageStore
        self.lastChangeCount = pasteboard.changeCount
    }

    // MARK: - Public API

    func start(onNewItem: @escaping (ClipItem) -> Void) {
        startKeyMonitor()

        // 100ms polling — changeCount is just an integer comparison, negligible CPU
        timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            MainActor.assumeIsolated {
                self?.pollClipboard(onNewItem: onNewItem)
            }
        }
    }

    func stop() {
        timer?.invalidate()
        timer = nil
        if let monitor = keyMonitor {
            NSEvent.removeMonitor(monitor)
            keyMonitor = nil
        }
    }

    /// Call *before* writing to the clipboard to prevent the observer
    /// from re-capturing its own write. Sets a flag so all polls are
    /// skipped until `finishOwnWrite()` is called.
    func skipNextChange() {
        isOwnWrite = true
    }

    /// Call *after* all pasteboard writes are done. Clears the skip flag
    /// and records the final changeCount so the next external change is
    /// detected correctly.
    func finishOwnWrite() {
        isOwnWrite = false
        lastChangeCount = pasteboard.changeCount
    }

    // MARK: - Cmd+C Monitor

    private func startKeyMonitor() {
        keyMonitor = NSEvent.addGlobalMonitorForEvents(matching: .keyDown) { [weak self] event in
            // Cmd+C: keyCode 8 = 'c'
            if event.modifierFlags.contains(.command) && event.keyCode == 8 {
                let bundleID = NSWorkspace.shared.frontmostApplication?.bundleIdentifier
                MainActor.assumeIsolated {
                    self?.lastCmdCApp = bundleID
                    self?.lastCmdCTimestamp = Date()
                }
            }
        }
    }

    // MARK: - Private

    /// Returns true if the pasteboard contains any sensitive type markers.
    private var isPasteboardSensitive: Bool {
        guard let types = pasteboard.types else { return false }
        return !Self.sensitiveTypes.isDisjoint(with: Set(types))
    }

    /// Checks if the most recent Cmd+C came from an excluded app (within last 2 seconds).
    private var wasCmdCFromExcludedApp: Bool {
        guard let timestamp = lastCmdCTimestamp,
              Date().timeIntervalSince(timestamp) < 2.0,
              let bundleID = lastCmdCApp else { return false }
        return exclusionManager?.isExcluded(bundleID: bundleID) == true
    }

    /// Determines if this clipboard change should be treated as sensitive.
    private var isSensitiveCapture: Bool {
        // Layer 1: Pasteboard type markers (most reliable — works regardless of app focus)
        if isPasteboardSensitive { return true }

        // Layer 2: Cmd+C was pressed in an excluded app (captures exact moment of copy)
        if wasCmdCFromExcludedApp { return true }

        // Layer 3: Frontmost app right now is excluded
        if exclusionManager?.shouldBlockCapture() == true { return true }

        return false
    }

    private func pollClipboard(onNewItem: @escaping (ClipItem) -> Void) {
        // Skip all polls while our own write is in progress
        guard !isOwnWrite else { return }

        let currentCount = pasteboard.changeCount
        guard currentCount != lastChangeCount else { return }
        lastChangeCount = currentCount

        // Check sensitivity BEFORE reading any content
        var sensitive = isSensitiveCapture

        // Capture source app info
        let frontmostApp = NSWorkspace.shared.frontmostApplication
        let sourceBundleID = frontmostApp?.bundleIdentifier
        let sourceName = frontmostApp?.localizedName

        // Check for text first
        if let string = pasteboard.string(forType: .string), !string.isEmpty {
            // Layer 5: Content-based password detection (catches what app detection misses)
            if !sensitive && PasswordDetector.looksLikePassword(string) {
                sensitive = true
            }

            let item = ClipItem(
                id: UUID(),
                type: .text,
                content: string,
                thumbnailPath: nil,
                filePath: nil,
                timestamp: Date(),
                isSensitive: sensitive,
                sourceAppBundleID: sourceBundleID,
                sourceAppName: sourceName
            )
            onNewItem(item)
            return
        }

        // Check for image (tiff or png)
        if let imageData = pasteboard.data(forType: .tiff) ?? pasteboard.data(forType: .png) {
            // If sensitive, don't store the image at all
            if sensitive {
                let item = ClipItem(
                    id: UUID(),
                    type: .image,
                    content: nil,
                    thumbnailPath: nil,
                    filePath: nil,
                    timestamp: Date(),
                    isSensitive: true,
                    sourceAppBundleID: sourceBundleID,
                    sourceAppName: sourceName
                )
                onNewItem(item)
                return
            }

            let id = UUID()
            if let paths = imageStore.saveImage(imageData, id: id) {
                let item = ClipItem(
                    id: id,
                    type: .image,
                    content: nil,
                    thumbnailPath: paths.thumbnailPath,
                    filePath: paths.filePath,
                    timestamp: Date(),
                    isSensitive: false,
                    sourceAppBundleID: sourceBundleID,
                    sourceAppName: sourceName
                )
                onNewItem(item)
            }
        }
    }
}
