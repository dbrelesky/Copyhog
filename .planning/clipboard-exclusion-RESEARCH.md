# Clipboard Source Detection on macOS - Research

**Researched:** 2026-02-21
**Domain:** macOS NSPasteboard, clipboard source attribution, password manager detection
**Confidence:** HIGH (core findings verified across multiple authoritative sources)

## Summary

macOS does NOT provide any public API to determine which application wrote to the clipboard. This is a confirmed platform limitation, not a gap in our research. The `NSPasteboard` API has no source PID, source bundle ID, or provenance field. The Maccy maintainer (the most popular open-source macOS clipboard manager) has confirmed: "macOS doesn't provide any means to inspect the source of the copy other than checking what window is currently focused."

The most reliable approach used by production clipboard managers (Yoink, Maccy, CopyQ) is a **layered detection strategy**: (1) check pasteboard types for sensitive markers, (2) check frontmost application at poll time, (3) use a time-window heuristic after excluded apps lose focus. Copyhog already implements approaches 2 and 3. The key improvement opportunity is in approach 1 -- checking for MORE pasteboard type markers, and potentially combining with CGEventTap-based Cmd+C detection for tighter timing.

**Primary recommendation:** Add detection of `com.agilebits.onepassword`, `org.nspasteboard.TransientType`, and `org.nspasteboard.AutoGeneratedType` pasteboard types alongside the existing `ConcealedType` check. For Dashlane specifically (which may not set any of these markers), use the CGEventTap approach to capture the frontmost app at the exact moment Cmd+C is pressed, eliminating the timing gap.

---

## Question 1: Can NSPasteboard Identify Which App Wrote to It?

**Answer: NO.** Confidence: HIGH

There is no public API on `NSPasteboard` that exposes the source application's PID, bundle identifier, or any provenance information. The pasteboard server (`/usr/libexec/pboard`) communicates with apps via XPC but does not expose the writer's identity to readers.

### The `org.nspasteboard.source` Convention

There is a **voluntary convention** defined at nspasteboard.org where apps can SET a pasteboard type called `org.nspasteboard.source` containing their bundle identifier as a UTF-8 string. However:

- This is **opt-in** -- apps must explicitly write this type
- Password managers generally do NOT set this (they want to be anonymous for security)
- It is meant for clipboard history apps re-posting content from other apps
- **Cannot be relied upon** for exclusion detection

### Verification Sources

- Maccy Issue #1072: Maintainer confirms "macOS doesn't provide any means to inspect the source of the copy other than checking what window is currently focused"
- Apple `NSPasteboard` documentation: No source/provenance properties exist
- The Eclectic Light Company article: pboard uses XPC but doesn't expose writer identity

---

## Question 2: What Pasteboard Types Do Password Managers Set?

**Confidence: MEDIUM-HIGH** (1Password well-documented, Dashlane unclear, Bitwarden confirmed)

### Known Pasteboard Types by App

| App | `ConcealedType` | `TransientType` | Custom Type | Notes |
|-----|:---:|:---:|---|---|
| 1Password (native app) | YES | Unknown | `com.agilebits.onepassword` | Also sets `org.nspasteboard.source` |
| 1Password (browser ext) | **NO** | Unknown | **NO** | Browser extensions bypass native pasteboard types entirely |
| Bitwarden (desktop) | YES | Unknown | None known | Added ConcealedType support ~2019 |
| Bitwarden (browser ext) | **NO** | Unknown | None known | Same browser limitation |
| Dashlane | **UNCLEAR** | Unknown | None documented | No evidence of ConcealedType support found |
| Apple Keychain/Passwords | Unknown | Unknown | None documented | Apple's own app |
| LastPass | Unknown | Unknown | None documented | |

### Critical Insight: Browser Extensions

**Browser extensions are the weak link.** When 1Password or Bitwarden copy passwords through their browser extension (which is the most common use case), the copy originates from the browser process (e.g., Safari, Chrome). This means:

- The pasteboard type markers are NOT set (browser JS cannot set custom pasteboard types)
- The frontmost app appears as "Safari" or "Chrome", not the password manager
- This is the primary reason ConcealedType detection alone is insufficient

### Pasteboard Types to Check

These are the types that production clipboard managers check:

```swift
// Types indicating sensitive/transient content
let sensitiveTypes: [NSPasteboard.PasteboardType] = [
    NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
    NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
    NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType"),
    NSPasteboard.PasteboardType("com.agilebits.onepassword"),
]
```

### Verification Sources

- nspasteboard.org: Documents `com.agilebits.onepassword` as a proprietary confidential marker
- 1Password community: Confirms browser extensions don't set ConcealedType
- Bitwarden GitHub issues #350 and #2633: Confirmed ConcealedType support added to desktop app
- Yoink blog post: Lists all four types above as their detection set

---

## Question 3: How Do Other Clipboard Managers Handle This?

**Confidence: HIGH** (Maccy and Yoink implementations verified from source/documentation)

### Maccy (Open Source, Most Popular)

**Detection method:** `NSWorkspace.shared.frontmostApplication` at poll time

- Polls clipboard via `changeCount` on a timer (configurable interval)
- Uses `frontmostApplication.bundleIdentifier` to attribute source
- Maintains an "Ignored Apps" list of bundle IDs
- Also checks for `ConcealedType`, `TransientType`, `AutoGeneratedType` in pasteboard types
- **Known limitation (Issue #1072):** When an app copies programmatically while another app is focused, Maccy attributes it incorrectly. Maintainer closed as "not planned" due to platform limitation.

### Yoink (Commercial, Polished)

**Detection method:** Dual approach -- app name matching + pasteboard type checking

1. **App name pattern matching:** Ignores copies from any app whose name contains: Keychain, Enpass, 1Password, KeePass, LastPass, Password, Kaspersky, mSecure, AppLocker, Keeper Password, Passwort, oneSafe, Secrets, Strongbox, RememBear, Dashlane, Bitwarden
2. **Pasteboard type filtering:** Ignores content containing: `com.agilebits.onepassword`, `org.nspasteboard.TransientType`, `org.nspasteboard.ConcealedType`, `org.nspasteboard.AutoGeneratedType`
3. **User-configurable "Ignored Apps" list** in preferences

**Key insight from Yoink:** They match on app NAME substrings (not just bundle IDs), which catches more cases. The word "Password" alone catches many password managers.

### CopyQ (Cross-Platform, Open Source)

**Detection method:** Pasteboard type checking only

- macOS: Checks for `application/x-nspasteboard-concealed-type` (their internal mapping of ConcealedType)
- Does not appear to do app-based exclusion on macOS

### Common Pattern Across All

Every production clipboard manager uses the **same fundamental approach**:
1. Check pasteboard types for known sensitive markers
2. Check frontmost app against exclusion list
3. Accept that some edge cases will slip through

**None of them have solved the "source app detection" problem** because macOS simply does not provide this information.

---

## Question 4: Can We Use `NSPasteboard.general.types` for Detection?

**Answer: YES, and this is the most reliable first-line defense.** Confidence: HIGH

### How to Inspect Types

```swift
let pasteboard = NSPasteboard.general
let types = pasteboard.types ?? []

// Check for any sensitive marker
let sensitiveMarkers: Set<NSPasteboard.PasteboardType> = [
    NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
    NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
    NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType"),
    NSPasteboard.PasteboardType("com.agilebits.onepassword"),
]

let isSensitive = !sensitiveMarkers.isDisjoint(with: Set(types))
```

### For Debugging: Log All Types

To discover what types Dashlane and other apps actually set, add temporary logging:

```swift
if let types = pasteboard.types {
    print("Pasteboard types: \(types.map { $0.rawValue })")
}
```

**Recommendation:** Add this debug logging to Copyhog temporarily, then copy a password from Dashlane and inspect the output. This will definitively answer whether Dashlane sets any detectable markers.

### Types Are Available Without Reading Content

Checking `pasteboard.types` does NOT count as "reading" the pasteboard content for the purposes of the upcoming macOS pasteboard privacy feature. Apple's new `detect` methods in macOS 15.4+ are specifically designed for this pattern.

---

## Question 5: Accessibility APIs / CGEventTap Approach

**Confidence: MEDIUM-HIGH** (CGEventTap is well-documented; this specific use case is novel)

### CGEventTap for Cmd+C Detection

The most promising approach for improving timing accuracy is intercepting the Cmd+C keystroke via `CGEventTapCreate`. This fires **immediately** when the user presses Cmd+C, before the clipboard is actually written, giving you the exact frontmost app at copy time.

**How it works:**

```swift
import Cocoa

final class CopyEventMonitor {
    private var eventTap: CFMachPort?
    private var lastCopyApp: String?
    private var lastCopyTimestamp: Date?

    func start() {
        let eventMask = (1 << CGEventType.keyDown.rawValue)

        guard let tap = CGEvent.tapCreate(
            tap: .cgSessionEventTap,
            place: .headInsertEventTap,
            options: .listenOnly,  // Don't modify events
            eventsOfInterest: CGEventMask(eventMask),
            callback: { proxy, type, event, refcon -> Unmanaged<CGEvent>? in
                let monitor = Unmanaged<CopyEventMonitor>
                    .fromOpaque(refcon!)
                    .takeUnretainedValue()
                monitor.handleKeyEvent(event)
                return Unmanaged.passRetained(event)
            },
            userInfo: Unmanaged.passUnretained(self).toOpaque()
        ) else {
            print("Failed to create event tap - check Accessibility permissions")
            return
        }

        eventTap = tap
        let runLoopSource = CFMachPortCreateRunLoopSource(
            kCFAllocatorDefault, tap, 0
        )
        CFRunLoopAddSource(
            CFRunLoopGetCurrent(), runLoopSource, .commonModes
        )
        CGEvent.tapEnable(tap: tap, enable: true)
    }

    private func handleKeyEvent(_ event: CGEvent) {
        let nsEvent = NSEvent(cgEvent: event)
        guard let nsEvent = nsEvent else { return }

        // Check for Cmd+C (keycode 8 = 'c')
        if nsEvent.modifierFlags.contains(.command)
            && nsEvent.keyCode == 8 {
            lastCopyApp = NSWorkspace.shared
                .frontmostApplication?.bundleIdentifier
            lastCopyTimestamp = Date()
        }
    }

    /// Call this from the clipboard poll to get the app that initiated the copy.
    /// Returns the bundle ID if Cmd+C was detected within the last 2 seconds.
    func recentCopySource() -> String? {
        guard let timestamp = lastCopyTimestamp,
              Date().timeIntervalSince(timestamp) < 2.0 else {
            return nil
        }
        return lastCopyApp
    }
}
```

### Requirements and Tradeoffs

| Aspect | Detail |
|--------|--------|
| Permission | Requires **Accessibility** permission (System Settings > Privacy > Accessibility) |
| App Sandbox | CGEventTap requires `com.apple.security.temporary-exception.sbpl` or running outside the App Store sandbox |
| Mac App Store | **NOT compatible** with Mac App Store distribution (requires sandbox exception) |
| Performance | Minimal -- only listening, not modifying events |
| Coverage | Catches Cmd+C only; does NOT catch programmatic copies (Edit > Copy menu, right-click > Copy, API calls) |

### Limitations of CGEventTap

- **Does not catch programmatic copies**: If Dashlane's autofill writes to the clipboard via API (not keyboard shortcut), CGEventTap won't fire
- **Does not catch Edit menu copies**: If user uses Edit > Copy from the menu bar, this may fire as a different event type
- **Requires Accessibility permission**: This is an additional permission request for users
- **App Store incompatible**: Cannot use this in a sandboxed App Store app

### Alternative: NSEvent.addGlobalMonitorForEvents

A lighter-weight alternative that does NOT require an event tap:

```swift
NSEvent.addGlobalMonitorForEvents(matching: .keyDown) { event in
    if event.modifierFlags.contains(.command) && event.keyCode == 8 {
        let app = NSWorkspace.shared.frontmostApplication?.bundleIdentifier
        // Record this as the copy source
    }
}
```

This also requires Accessibility permissions but is somewhat simpler. However, it has the same limitations as CGEventTap regarding programmatic copies.

---

## Question 6: Faster Polling Interval

**Confidence: HIGH**

### Current: 0.5s (500ms)

The current 0.5s interval means up to 500ms between clipboard change and detection. During this time, the user may have already switched apps (especially with keyboard shortcuts like Cmd+Tab).

### Recommended: 0.1s (100ms) for `changeCount` Check Only

Checking `pasteboard.changeCount` is extremely lightweight -- it's just comparing an integer. Multiple production tools (klipsustreamer, Maccy) use 100ms intervals.

```swift
// Only the changeCount check runs at 100ms
// Actual content reading still happens only on change
Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
    let count = NSPasteboard.general.changeCount
    guard count != self.lastChangeCount else { return }
    // Change detected -- NOW check frontmost app and read content
}
```

**Performance impact:** Negligible. `changeCount` is a simple property read, not a pasteboard content read.

### How This Helps

With 100ms polling:
- The maximum delay between Cmd+C and detection is 100ms instead of 500ms
- At 100ms, the user is much less likely to have already switched apps
- Combined with `didDeactivateApplicationNotification`, the time-window heuristic becomes much more reliable

### Diminishing Returns Below 100ms

Going below 100ms (e.g., 50ms, 10ms) provides marginal improvement and may trigger macOS pasteboard privacy alerts more aggressively in future macOS versions.

---

## Question 7: Private APIs and Entitlements

**Confidence: MEDIUM** (based on available documentation; private APIs are by nature undocumented)

### Known Private/Restricted APIs

| API | What It Could Do | Why You Can't Use It |
|-----|-----------------|---------------------|
| EndpointSecurity framework | Monitor all process syscalls including XPC to pboard | Requires Apple-granted `com.apple.developer.endpoint-security.client` entitlement; only for MDM/security vendors |
| `com.apple.CFPasteboard` log subsystem | Unified log may show which process wrote to clipboard | Read-only diagnostic; not a real-time API; requires `log` command access |
| XPC interception of pboard | Could theoretically intercept pboard XPC messages | No public API; would require SIP-disabled system |
| `com.apple.is-remote-clipboard` | Detects Handoff clipboard content | Only useful for detecting remote copies, not source apps |

### No Known Private API for Source PID

After extensive research, there is **no known private API** that exposes the source process of a clipboard write. Even if one existed, using it would:
- Be rejected from Mac App Store
- Break on any macOS update
- Potentially require SIP to be disabled

### macOS Pasteboard Privacy (macOS 15.4+ / macOS 26 Tahoe)

**IMPORTANT future consideration:** Apple is adding pasteboard privacy protections:

- Apps will need user permission to read the general pasteboard programmatically
- `NSPasteboard.accessBehavior` property indicates current permission state
- New `detect` methods allow checking pasteboard types WITHOUT triggering alerts
- Users configure per-app permissions in System Settings > Privacy > Paste from Other Apps
- Three settings: Ask, Allow, Deny
- Clipboard managers MUST get "Always Allow" to function

**Impact on Copyhog:**
- Polling-based clipboard monitoring will require explicit user permission
- The `detect` API can check types without triggering alerts (good for sensitive marker detection)
- Users will need to grant Copyhog permission in System Settings
- This is already shipping as a preview in macOS 15.4

---

## Recommended Strategy for Copyhog

### Layered Detection (Priority Order)

```
Layer 1: Pasteboard Type Detection (most reliable)
  - Check for ConcealedType, TransientType, AutoGeneratedType, com.agilebits.onepassword
  - Runs on every clipboard change
  - Works regardless of which app is frontmost
  - Does NOT catch Dashlane or browser extension copies

Layer 2: Frontmost App Check (fast, catches most cases)
  - Check NSWorkspace.shared.frontmostApplication at poll time
  - With 100ms polling, this catches most manual copies from excluded apps
  - Fails when user switches apps between copy and poll

Layer 3: CGEventTap / NSEvent Global Monitor (catches Cmd+C timing)
  - Records frontmost app at exact moment of Cmd+C
  - Clipboard poll checks if recent Cmd+C came from excluded app
  - Catches the timing gap that Layer 2 misses
  - Requires Accessibility permission
  - Does NOT catch programmatic/menu copies

Layer 4: Time-Window Heuristic (existing, fallback)
  - If excluded app was active within last N seconds, block
  - Tune window based on polling interval (with 100ms poll, 1-2s window may suffice)
  - Catches remaining edge cases at the cost of some false positives
```

### Specific Improvements Over Current Implementation

1. **Add more pasteboard type checks** (TransientType, AutoGeneratedType, com.agilebits.onepassword)
2. **Reduce polling interval** from 500ms to 100ms
3. **Add CGEventTap/NSEvent global monitor** for Cmd+C to capture frontmost app at copy time
4. **Reduce time-window** from 3s to 1.5s (faster polling makes shorter window viable)
5. **Add debug logging** for pasteboard types to discover what Dashlane actually sets
6. **Add Yoink-style app name matching** as additional heuristic (check if app name contains "Password", "Dashlane", etc.)

### For Dashlane Specifically

Since Dashlane may not set ConcealedType:
1. First: Add debug logging and test what pasteboard types Dashlane actually writes
2. If no markers: The CGEventTap approach + faster polling is the best bet
3. App name matching ("Dashlane" in process name) can catch copies from the native Dashlane app
4. For Dashlane browser extension copies: These come from the browser process and are essentially **undetectable** without user cooperation (the user would need to add Safari/Chrome to the exclusion list, which is too broad)

---

## Common Pitfalls

### Pitfall 1: Assuming ConcealedType Is Universal
**What goes wrong:** Only checking for ConcealedType and missing password copies from apps that don't set it
**Why:** Many password managers (especially browser extensions) don't set any nspasteboard markers
**Prevention:** Use layered detection; never rely on a single signal

### Pitfall 2: Reading Content Before Checking Sensitivity
**What goes wrong:** The sensitive content is already in memory/logs by the time you decide to redact
**Prevention:** Check `pasteboard.types` BEFORE reading `pasteboard.string(forType:)` or `pasteboard.data(forType:)`

### Pitfall 3: Too-Long Time Windows Causing False Positives
**What goes wrong:** User copies from a normal app 2 seconds after leaving 1Password, and it gets redacted
**Prevention:** Use shortest viable window; combine with faster polling to reduce needed window duration

### Pitfall 4: CGEventTap Failing Silently
**What goes wrong:** Event tap creation returns nil because Accessibility permission wasn't granted; app silently falls back to less reliable detection
**Prevention:** Check for tap creation failure, inform user they need to grant Accessibility permission for best protection

### Pitfall 5: macOS Pasteboard Privacy Breaking Polling
**What goes wrong:** On macOS 15.4+/26, polling triggers repeated permission alerts or is silently blocked
**Prevention:** Use `NSPasteboard.accessBehavior` to check permission state; guide user to grant "Always Allow"; use `detect` methods for type checking where possible

---

## Open Questions

1. **What pasteboard types does Dashlane actually set?**
   - What we know: Dashlane is not listed on nspasteboard.org as supporting ConcealedType
   - What's unclear: Whether Dashlane sets ANY custom pasteboard types
   - Recommendation: Add debug logging, test empirically, and report findings

2. **Does Copyhog need Mac App Store compatibility?**
   - What we know: CGEventTap requires sandbox exceptions incompatible with App Store
   - What's unclear: Distribution method for Copyhog
   - Recommendation: If distributing outside App Store, CGEventTap is viable. If App Store, stick with NSEvent.addGlobalMonitorForEvents (still needs Accessibility)

3. **How will macOS 26 Tahoe pasteboard privacy affect Copyhog?**
   - What we know: Users will need to grant explicit permission; `detect` methods allow type-checking without alerts
   - What's unclear: Exact behavior for clipboard managers; whether Apple provides a special entitlement
   - Recommendation: Prepare migration path; test with macOS 15.4 preview; ensure onboarding guides users to grant permission

---

## Sources

### Primary (HIGH confidence)
- [nspasteboard.org](http://nspasteboard.org/) - Definitive reference for pasteboard type conventions
- [Apple NSPasteboard Documentation](https://developer.apple.com/documentation/appkit/nspasteboard)
- [Maccy GitHub - Clipboard.swift](https://github.com/p0deje/Maccy/blob/master/Maccy/Clipboard.swift) - Production clipboard manager source code
- [Maccy Issue #1072](https://github.com/p0deje/Maccy/issues/1072) - Maintainer confirms no source detection API exists

### Secondary (MEDIUM confidence)
- [Yoink's Clipboard History and Your Privacy](https://blog.eternalstorms.at/2022/02/22/yoinks-clipboard-history-and-your-privacy/) - Production detection strategy
- [1Password Community - ConcealedType](https://1password.community/discussion/126414/) - Browser extensions don't set ConcealedType
- [Bitwarden Desktop Issue #350](https://github.com/bitwarden/desktop/issues/350) - ConcealedType support added
- [CopyQ PR #2500](https://github.com/hluk/CopyQ/pull/2500) - Cross-platform clipboard security detection
- [Eclectic Light Company - Pasteboard Internals](https://eclecticlight.co/2020/05/12/cut-copy-paste-inside-the-pasteboard-clipboard/)
- [Michael Tsai - Pasteboard Privacy Preview](https://mjtsai.com/blog/2025/05/12/pasteboard-privacy-preview-in-macos-15-4/)

### Tertiary (LOW confidence - needs validation)
- CGEventTap approach for Cmd+C interception: Well-documented API but novel application for clipboard source detection; needs testing
- Dashlane ConcealedType support status: Could not find definitive documentation; needs empirical testing
