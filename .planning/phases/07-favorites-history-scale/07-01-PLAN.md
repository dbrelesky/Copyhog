---
phase: 07-favorites-history-scale
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Copyhog/Copyhog/Models/ClipItem.swift
  - Copyhog/Copyhog/Store/ClipItemStore.swift
  - Copyhog/Copyhog/Services/ImageStore.swift
  - Copyhog/Copyhog/Views/SettingsMenu.swift
  - Copyhog/Copyhog/CopyhogApp.swift
autonomous: true
requirements: [FAV-01, FAV-03, FAV-04, HIST-01, HIST-02, HIST-03]

must_haves:
  truths:
    - "ClipItem has isPinned field that defaults to false for existing persisted items"
    - "Pinned items are never removed by auto-purge; only unpinned items are purged"
    - "Toggling pin re-sorts items so pinned appear first, then by timestamp"
    - "Saving 500 items does not block the main thread (debounced background writes)"
    - "Thumbnail images are cached in NSCache and not re-read from disk on every scroll"
    - "History limit can be set up to 500 in settings"
    - "Pending saves are flushed on app termination so no data is lost"
  artifacts:
    - path: "Copyhog/Copyhog/Models/ClipItem.swift"
      provides: "isPinned Bool field with backward-compatible decoding"
      contains: "isPinned"
    - path: "Copyhog/Copyhog/Store/ClipItemStore.swift"
      provides: "togglePin, debounced save, pinned-aware purge"
      exports: ["togglePin", "scheduleSave"]
    - path: "Copyhog/Copyhog/Services/ImageStore.swift"
      provides: "NSCache thumbnail caching layer"
      contains: "thumbnailCache"
    - path: "Copyhog/Copyhog/Views/SettingsMenu.swift"
      provides: "Extended history size picker (up to 500)"
      contains: "500"
  key_links:
    - from: "Copyhog/Copyhog/Store/ClipItemStore.swift"
      to: "Copyhog/Copyhog/Models/ClipItem.swift"
      via: "isPinned field access in togglePin and purge"
      pattern: "isPinned"
    - from: "Copyhog/Copyhog/CopyhogApp.swift"
      to: "Copyhog/Copyhog/Store/ClipItemStore.swift"
      via: "flush pending save on app termination"
      pattern: "flushSave|performSave"
---

<objective>
Add isPinned to ClipItem data model, implement pin/unpin and pinned-aware purge in ClipItemStore, replace synchronous save with debounced background persistence, add NSCache thumbnail caching to ImageStore, and extend history limit to 500 in settings.

Purpose: This is the data foundation for favorites and history scale -- all UI work in Plan 02 depends on these model and store changes.
Output: Updated ClipItem model, ClipItemStore with pin/debounce/purge, ImageStore with caching, extended settings picker.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-favorites-history-scale/07-RESEARCH.md
@Copyhog/Copyhog/Models/ClipItem.swift
@Copyhog/Copyhog/Store/ClipItemStore.swift
@Copyhog/Copyhog/Services/ImageStore.swift
@Copyhog/Copyhog/Views/SettingsMenu.swift
@Copyhog/Copyhog/CopyhogApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isPinned to ClipItem, implement pin/unpin + debounced save + pinned-aware purge in ClipItemStore</name>
  <files>
    Copyhog/Copyhog/Models/ClipItem.swift
    Copyhog/Copyhog/Store/ClipItemStore.swift
    Copyhog/Copyhog/CopyhogApp.swift
  </files>
  <action>
    **ClipItem.swift:**
    1. Add `var isPinned: Bool` property (mutable, not let -- needs toggling)
    2. Add `isPinned` to CodingKeys enum
    3. In `init(from decoder:)`, decode with `decodeIfPresent(Bool.self, forKey: .isPinned) ?? false` for backward compatibility with existing items.json
    4. Add `isPinned: Bool = false` parameter to the memberwise init
    5. Update the `markSensitive` reconstruction in ClipItemStore to pass through isPinned

    **ClipItemStore.swift:**
    1. Add `private var saveTask: Task<Void, Never>?` property
    2. Add `func togglePin(id: UUID)` -- find item by id, toggle `isPinned`, re-sort items (pinned first, then by timestamp descending within each group), call `scheduleSave()`
    3. Replace the synchronous `save()` method with:
       - `private func scheduleSave()` -- cancels existing saveTask, creates new Task that sleeps 500ms then calls performSave()
       - `private func performSave()` -- captures items array, encodes on a detached Task with iso8601 date strategy, writes atomically to storeURL
       - Keep a `func flushSave()` public method that cancels the debounce task and calls performSave() immediately (for app termination)
    4. Update `add()` purge logic: instead of `items.removeLast()`, find `items.lastIndex(where: { !$0.isPinned })` and remove that. If no unpinned item exists, break (all pinned, cannot purge)
    5. Update all existing callers of `save()` to use `scheduleSave()` instead (add, remove, removeAll, markSensitive)
    6. After `load()` in init, sort items so pinned items appear first (maintains order on app restart)

    **CopyhogApp.swift (AppDelegate):**
    1. In `applicationWillTerminate`, add `store.flushSave()` call to flush any pending debounced save before the app exits
  </action>
  <verify>Build the project with `xcodebuild build -project Copyhog/Copyhog.xcodeproj -scheme Copyhog -destination 'platform=macOS' 2>&1 | tail -5` -- should compile with 0 errors. Verify isPinned field exists in ClipItem, togglePin exists in ClipItemStore, and flushSave is called in applicationWillTerminate.</verify>
  <done>ClipItem has isPinned with backward-compatible decoding. ClipItemStore has togglePin, debounced save (500ms), pinned-aware purge, and flushSave. AppDelegate flushes on termination. Project compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Add NSCache thumbnail caching to ImageStore and extend history settings picker to 500</name>
  <files>
    Copyhog/Copyhog/Services/ImageStore.swift
    Copyhog/Copyhog/Views/SettingsMenu.swift
  </files>
  <action>
    **ImageStore.swift:**
    1. Add `private let thumbnailCache = NSCache<NSString, NSImage>()` property
    2. In `init()`, set `thumbnailCache.countLimit = 200` (keep up to 200 thumbnails in memory; auto-evicts under pressure)
    3. Update `loadImage(relativePath:)` to check cache first: if `thumbnailCache.object(forKey: relativePath as NSString)` returns non-nil, return it. Otherwise load from disk, store in cache with `thumbnailCache.setObject(image, forKey: key)`, then return.
    4. Add `func invalidateCache(relativePath: String)` that calls `thumbnailCache.removeObject(forKey: relativePath as NSString)` -- called when an image is deleted
    5. Update `deleteImage(relativePath:)` to also call `invalidateCache(relativePath:)` before deleting from disk

    **SettingsMenu.swift:**
    1. Update the `historySizePicker` computed property to include larger values. Replace current options (10, 20, 30, 40, 50) with: 20, 50, 100, 200, 500. This matches HIST-01 requirement for 500-item support.
  </action>
  <verify>Build the project with `xcodebuild build -project Copyhog/Copyhog.xcodeproj -scheme Copyhog -destination 'platform=macOS' 2>&1 | tail -5` -- should compile with 0 errors. Verify NSCache property exists in ImageStore and settings picker includes 500 option.</verify>
  <done>ImageStore caches thumbnails in NSCache with 200 countLimit and auto-invalidates on delete. Settings picker offers 20/50/100/200/500 history sizes. Project compiles.</done>
</task>

</tasks>

<verification>
1. `xcodebuild build` completes with 0 errors
2. ClipItem.swift contains `var isPinned: Bool` and backward-compatible decoding
3. ClipItemStore.swift contains togglePin, scheduleSave, performSave, flushSave methods
4. Purge logic in add() skips pinned items
5. ImageStore.swift contains NSCache thumbnailCache with countLimit 200
6. SettingsMenu.swift picker includes 500 option
7. AppDelegate calls flushSave() in applicationWillTerminate
</verification>

<success_criteria>
- Existing items.json loads without error (isPinned defaults to false)
- Pin/unpin toggle works via store.togglePin(id:)
- Purge removes only unpinned items when history exceeds limit
- Saves are debounced at 500ms and encoded off main thread
- Pending saves flush on app termination
- Thumbnails are cached in memory after first load
- History limit configurable up to 500 in settings
</success_criteria>

<output>
After completion, create `.planning/phases/07-favorites-history-scale/07-01-SUMMARY.md`
</output>
