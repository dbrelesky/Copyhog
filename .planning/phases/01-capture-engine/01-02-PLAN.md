---
phase: 01-capture-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Copyhog/Copyhog/Models/ClipItem.swift
  - Copyhog/Copyhog/Store/ClipItemStore.swift
  - Copyhog/Copyhog/Services/ClipboardObserver.swift
  - Copyhog/Copyhog/Services/ScreenshotWatcher.swift
  - Copyhog/Copyhog/Services/ImageStore.swift
  - Copyhog/Copyhog/CopyhogApp.swift
autonomous: false

must_haves:
  truths:
    - "Copying text anywhere on the system creates a new entry in the item store within 1 second"
    - "Copying an image anywhere on the system creates a new entry in the item store within 1 second"
    - "Taking a screenshot results in the file appearing in ~/Documents/Screenies/"
    - "Taking a screenshot results in the image being copied to the system clipboard"
    - "The store holds exactly 20 items max, purging the oldest when exceeded"
    - "Items survive an app restart"
    - "Capturing a screenshot does not create duplicate entries (no infinite loop)"
  artifacts:
    - path: "Copyhog/Copyhog/Models/ClipItem.swift"
      provides: "Codable model with id, type, content, thumbnailPath, filePath, timestamp"
      contains: "ClipItem"
    - path: "Copyhog/Copyhog/Store/ClipItemStore.swift"
      provides: "Observable store with 20-item cap, JSON persistence, add/load/save"
      contains: "ClipItemStore"
    - path: "Copyhog/Copyhog/Services/ClipboardObserver.swift"
      provides: "Timer-based NSPasteboard.changeCount polling at 0.5s for text and images"
      contains: "ClipboardObserver"
    - path: "Copyhog/Copyhog/Services/ScreenshotWatcher.swift"
      provides: "DispatchSource directory watcher, moves screenshots to ~/Documents/Screenies/, copies to clipboard"
      contains: "ScreenshotWatcher"
    - path: "Copyhog/Copyhog/Services/ImageStore.swift"
      provides: "Save/load image files to ~/Library/Application Support/Copyhog/"
      contains: "ImageStore"
  key_links:
    - from: "ClipboardObserver.swift"
      to: "ClipItemStore.swift"
      via: "onNewItem callback calling store.add()"
      pattern: "store\\.add|onNewItem"
    - from: "ScreenshotWatcher.swift"
      to: "NSPasteboard.general"
      via: "Copies screenshot image to system clipboard"
      pattern: "pasteboard.*writeObjects|clearContents"
    - from: "ScreenshotWatcher.swift"
      to: "~/Documents/Screenies/"
      via: "FileManager.moveItem moves screenshot to Screenies directory"
      pattern: "moveItem|Screenies"
    - from: "ClipboardObserver.swift"
      to: "NSPasteboard.general.changeCount"
      via: "Timer polling every 0.5s comparing changeCount"
      pattern: "changeCount"
    - from: "CopyhogApp.swift"
      to: "ClipboardObserver.swift"
      via: "App initializes and starts the observer"
      pattern: "ClipboardObserver|observer\\.start"
    - from: "CopyhogApp.swift"
      to: "ScreenshotWatcher.swift"
      via: "App initializes and starts the watcher"
      pattern: "ScreenshotWatcher|watcher\\.start"
    - from: "ClipItemStore.swift"
      to: "~/Library/Application Support/Copyhog/items.json"
      via: "JSON encode/decode for persistence"
      pattern: "JSONEncoder|JSONDecoder|items\\.json"
---

<objective>
Implement clipboard observer, screenshot watcher, image storage, and persistent item store — the capture engine that detects every clipboard copy and screenshot, stores them, and persists across restarts.

Purpose: This is the core value of Copyhog — automatic capture. Without this, the app is an empty shell.
Output: Working clipboard polling, screenshot directory watching with move-to-Screenies and copy-to-clipboard, image file storage, and a 20-item persistent store.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-capture-engine/01-RESEARCH.md
@.planning/phases/01-capture-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClipItem model, ImageStore, and ClipItemStore with persistence</name>
  <files>
    Copyhog/Copyhog/Models/ClipItem.swift
    Copyhog/Copyhog/Services/ImageStore.swift
    Copyhog/Copyhog/Store/ClipItemStore.swift
  </files>
  <action>
    1. **ClipItem.swift** — Create the Codable model:
       ```swift
       struct ClipItem: Codable, Identifiable {
           let id: UUID
           let type: ItemType
           let content: String?        // Text content (nil for images)
           let thumbnailPath: String?   // Relative path to thumbnail in App Support
           let filePath: String?        // Relative path to full image in App Support
           let timestamp: Date

           enum ItemType: String, Codable {
               case text
               case image
           }
       }
       ```
       Use relative paths (not absolute) for thumbnailPath and filePath so they survive app relocations. Paths are relative to the App Support/Copyhog/ directory.

    2. **ImageStore.swift** — Service for saving/loading images to `~/Library/Application Support/Copyhog/`:
       - `saveImage(_ imageData: Data, id: UUID) -> (filePath: String, thumbnailPath: String)?` — saves full image as `{id}.png` and generates a thumbnail (64x64) as `{id}_thumb.png`. Returns relative paths.
       - `loadImage(relativePath: String) -> NSImage?` — loads image from relative path under App Support.
       - `deleteImage(relativePath: String)` — removes image file.
       - Use `FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)` to get the base directory. Create `Copyhog/` subdirectory if it doesn't exist.
       - For thumbnail generation: Create `NSImage` from data, then draw into a 64x64 `NSBitmapImageRep`, export as PNG.

    3. **ClipItemStore.swift** — Observable store with persistence:
       - Class conforming to `ObservableObject` with `@Published var items: [ClipItem] = []`
       - `private let maxItems = 20`
       - `private let storeURL: URL` — points to `~/Library/Application Support/Copyhog/items.json`
       - `init()` — creates App Support/Copyhog/ directory, sets storeURL, calls `load()`
       - `func add(_ item: ClipItem)` — inserts at index 0, if count > maxItems removes last item AND cleans up its image files via ImageStore, then calls `save()`
       - `private func save()` — `JSONEncoder` with `.iso8601` dateEncodingStrategy, write to storeURL
       - `private func load()` — `JSONDecoder` with `.iso8601` dateDecodingStrategy, read from storeURL
       - Store an `imageStore: ImageStore` reference for cleanup operations

    Verify: `xcodebuild build` succeeds.
  </action>
  <verify>
    `xcodebuild -project Copyhog/Copyhog.xcodeproj -scheme Copyhog build 2>&1 | tail -5` shows "BUILD SUCCEEDED".
    `grep -c "ClipItem" Copyhog/Copyhog/Models/ClipItem.swift` returns at least 1.
    `grep -c "maxItems" Copyhog/Copyhog/Store/ClipItemStore.swift` returns at least 1.
    `grep -c "items.json" Copyhog/Copyhog/Store/ClipItemStore.swift` returns at least 1.
  </verify>
  <done>
    ClipItem model is Codable with all required fields. ImageStore saves/loads/deletes images in App Support. ClipItemStore persists up to 20 items as JSON, auto-purges oldest with image cleanup. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ClipboardObserver, ScreenshotWatcher, and wire into app</name>
  <files>
    Copyhog/Copyhog/Services/ClipboardObserver.swift
    Copyhog/Copyhog/Services/ScreenshotWatcher.swift
    Copyhog/Copyhog/CopyhogApp.swift
  </files>
  <action>
    1. **ClipboardObserver.swift** — Timer-based clipboard polling:
       - Properties: `private var timer: Timer?`, `private var lastChangeCount: Int`, `private let pasteboard = NSPasteboard.general`, `var isOwnWrite = false`
       - `init()` — set `lastChangeCount = pasteboard.changeCount`
       - `func start(onNewItem: @escaping (ClipItem) -> Void)` — creates `Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true)` that:
         a. Reads `pasteboard.changeCount`, skips if unchanged
         b. Updates `lastChangeCount`
         c. **CRITICAL: Checks `isOwnWrite` flag — if true, skip processing and reset flag.** This prevents infinite capture loop when ScreenshotWatcher copies images to clipboard.
         d. Checks for text first: `pasteboard.string(forType: .string)` — if found, create `ClipItem(id: UUID(), type: .text, content: string, thumbnailPath: nil, filePath: nil, timestamp: Date())`
         e. Checks for image: `pasteboard.data(forType: .tiff)` or `.png` — if found, save via ImageStore, create `ClipItem` with image type and file paths
         f. Calls `onNewItem(item)`
       - `func stop()` — invalidate timer
       - `func skipNextChange()` — sets `isOwnWrite = true` AND immediately updates `lastChangeCount = pasteboard.changeCount` after the external write. This is the mechanism ScreenshotWatcher uses to avoid the infinite loop.

    2. **ScreenshotWatcher.swift** — Directory monitoring with DispatchSource:
       - Properties: `private var source: DispatchSourceFileSystemObject?`, `private var fileDescriptor: Int32 = -1`, `private var knownFiles: Set<String>` (tracks existing files to detect new ones)
       - `func screenshotDirectory() -> URL` — reads `defaults read com.apple.screencapture location`, falls back to `~/Desktop`. Use `Process` to run the defaults command.
       - `func start(clipboardObserver: ClipboardObserver, imageStore: ImageStore, onNewItem: @escaping (ClipItem) -> Void)`:
         a. Determine screenshot directory via `screenshotDirectory()`
         b. Create `~/Documents/Screenies/` directory if it doesn't exist
         c. Enumerate existing `.png` files in screenshot directory, add to `knownFiles`
         d. Open directory with `open(directory.path, O_EVTONLY)`, store file descriptor
         e. Create `DispatchSource.makeFileSystemObjectSource(fileDescriptor:eventMask:.write, queue:.main)`
         f. In event handler: **wait 0.5s** (DispatchQueue.main.asyncAfter) for file to finish writing, then enumerate directory for new `.png` files not in `knownFiles`. For each new file:
            - Verify file is a screenshot (filename starts with "Screenshot" or matches macOS screenshot naming pattern `Screenshot YYYY-MM-DD at HH.MM.SS`)
            - Verify file size is stable (read size, wait 0.2s, read again — if different, retry)
            - Move file to `~/Documents/Screenies/` using `FileManager.default.moveItem`
            - Read the image data from the new location
            - Save to ImageStore for the item store
            - **Copy to system clipboard:** `clipboardObserver.skipNextChange()` THEN `pasteboard.clearContents(); pasteboard.writeObjects([NSImage(data:)!])` — the skipNextChange call MUST happen before the write to prevent infinite loop
            - Create `ClipItem` with image type, call `onNewItem`
            - Add filename to `knownFiles`
         g. Set cancel handler that closes file descriptor
         h. Resume source
       - `func stop()` — cancel source, close fd

    3. **Wire into CopyhogApp.swift:**
       - Add `@StateObject private var store = ClipItemStore()` (may already exist from Plan 01-01)
       - Create `ClipboardObserver` and `ScreenshotWatcher` as properties
       - In `init()` or an `AppDelegate` adapter:
         a. Start `ClipboardObserver` with callback: `{ [weak store] item in store?.add(item) }`
         b. Start `ScreenshotWatcher` with reference to clipboard observer, image store, and same add callback
       - Pass `store` as `@EnvironmentObject` to `PopoverContent` (already done in Plan 01-01)
       - **Note on lifecycle:** Services must start when the app launches and keep running. Use `@StateObject` or store references in the App struct to keep them alive. Do NOT start them in a view's `.onAppear` — that only fires when the popover opens.

    Verify: `xcodebuild build` succeeds. All service files contain their key patterns.
  </action>
  <verify>
    `xcodebuild -project Copyhog/Copyhog.xcodeproj -scheme Copyhog build 2>&1 | tail -5` shows "BUILD SUCCEEDED".
    `grep -c "changeCount" Copyhog/Copyhog/Services/ClipboardObserver.swift` returns at least 2.
    `grep -c "isOwnWrite\|skipNextChange" Copyhog/Copyhog/Services/ClipboardObserver.swift` returns at least 2 (loop prevention).
    `grep -c "DispatchSource" Copyhog/Copyhog/Services/ScreenshotWatcher.swift` returns at least 1.
    `grep -c "Screenies" Copyhog/Copyhog/Services/ScreenshotWatcher.swift` returns at least 1.
    `grep -c "moveItem" Copyhog/Copyhog/Services/ScreenshotWatcher.swift` returns at least 1.
    `grep -c "ClipboardObserver\|ScreenshotWatcher" Copyhog/Copyhog/CopyhogApp.swift` returns at least 2 (wired into app).
  </verify>
  <done>
    ClipboardObserver polls NSPasteboard.changeCount every 0.5s and captures text and image content. ScreenshotWatcher monitors the screenshot directory via DispatchSource, moves new screenshots to ~/Documents/Screenies/, and copies them to clipboard (with infinite-loop prevention via skipNextChange). Both services are wired into the app and feed into ClipItemStore. Build succeeds.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify capture engine end-to-end</name>
  <action>
    Human verification checkpoint. What was built: Complete capture engine — clipboard observer captures text and images, screenshot watcher moves files and copies to clipboard, item store persists 20 items across restarts.

    Steps to verify:
    1. Build and run the app (Xcode Cmd+R or xcodebuild + open from DerivedData)
    2. **Test text capture:** Open any app, copy some text (Cmd+C). Check `~/Library/Application Support/Copyhog/items.json` — should contain a text entry within 1 second
    3. **Test image capture:** Copy an image from a browser or Preview. Check items.json — should contain an image entry with filePath pointing to a file in App Support
    4. **Test screenshot capture:** Press Cmd+Shift+4 and take a screenshot. Verify:
       - The screenshot file appears in `~/Documents/Screenies/` (not left on Desktop)
       - The screenshot image is now on the system clipboard (paste into any app to verify)
       - items.json contains a new image entry for the screenshot
    5. **Test 20-item cap:** Copy text 21+ times. Verify items.json has exactly 20 entries
    6. **Test persistence:** Quit the app (Cmd+Q from menu bar or force quit). Relaunch. Verify items.json still has the items (they survived restart)
    7. **Test no infinite loop:** After a screenshot capture, verify only ONE new entry appears in items.json (not duplicates)
  </action>
  <verify>User confirms all 7 verification steps pass</verify>
  <done>User types "approved" — capture engine verified working end-to-end</done>
</task>

</tasks>

<verification>
Phase 1 Plan 02 checks:
- [ ] Clipboard text capture works within 1 second of copy
- [ ] Clipboard image capture works within 1 second of copy
- [ ] Screenshot files moved to ~/Documents/Screenies/
- [ ] Screenshots copied to system clipboard automatically
- [ ] No infinite capture loop on screenshot → clipboard copy
- [ ] Store holds max 20 items, purges oldest
- [ ] Items persist in items.json across app restart
- [ ] All image files stored in ~/Library/Application Support/Copyhog/
</verification>

<success_criteria>
1. Text copied anywhere appears as ClipItem in store within 1s
2. Image copied anywhere appears as ClipItem with saved file in App Support
3. Screenshot taken → file in ~/Documents/Screenies/ + image on clipboard + ClipItem in store
4. No duplicate entries from screenshot capture (infinite loop prevention works)
5. 21st item causes oldest to be purged (store stays at 20)
6. Quit and relaunch — items.json loads correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-capture-engine/01-02-SUMMARY.md`
</output>
