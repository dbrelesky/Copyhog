---
phase: 08-search-keyboard-navigation
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - Copyhog/Copyhog/Views/PopoverContent.swift
autonomous: true
requirements:
  - KBNAV-01
  - KBNAV-02
  - KBNAV-03
  - KBNAV-04

must_haves:
  truths:
    - "User can press arrow keys to move selection through items in the grid"
    - "User can press Enter on a selected item to copy it to clipboard"
    - "User can press Escape to clear search first, then dismiss popover on second press"
    - "User can press Tab to move focus between search field and item list"
    - "Preview pane updates to show the keyboard-selected item"
    - "Scroll follows keyboard selection so selected item is always visible"
    - "On popover open, first list item is selected (not search field)"
  artifacts:
    - path: "Copyhog/Copyhog/Views/PopoverContent.swift"
      provides: "NSEvent local monitor for keyboard handling, selectedIndex state, focus management"
      contains: "addLocalMonitorForEvents"
  key_links:
    - from: "Copyhog/Copyhog/Views/PopoverContent.swift"
      to: "NSEvent"
      via: "addLocalMonitorForEvents(matching: .keyDown) for arrow/Enter/Escape/Tab handling"
      pattern: "NSEvent\\.addLocalMonitorForEvents"
    - from: "Copyhog/Copyhog/Views/PopoverContent.swift"
      to: "Copyhog/Copyhog/Views/ItemRow.swift"
      via: "isSelected parameter driven by selectedIndex matching item ID"
      pattern: "isSelected:"
    - from: "Copyhog/Copyhog/Views/PopoverContent.swift"
      to: "Copyhog/Copyhog/Services/PasteboardWriter.swift"
      via: "Enter key triggers PasteboardWriter.write for selected item"
      pattern: "PasteboardWriter\\.write"
---

<objective>
Add full keyboard navigation to the clipboard history popover using NSEvent local monitor. Arrow keys move selection through the 3-column grid, Enter copies the selected item, Escape clears search then dismisses, and Tab toggles focus between search field and item list. The preview pane updates to reflect the keyboard-selected item.

Purpose: Users can navigate and copy clipboard history items entirely from the keyboard, enabling fast power-user workflows.
Output: Complete keyboard navigation with arrow keys, Enter, Escape, Tab focus management, and scroll-to-selection.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-search-keyboard-navigation/08-RESEARCH.md
@.planning/phases/08-search-keyboard-navigation/08-01-SUMMARY.md
@Copyhog/Copyhog/Views/PopoverContent.swift
@Copyhog/Copyhog/Views/ItemRow.swift
@Copyhog/Copyhog/Services/PasteboardWriter.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install NSEvent local monitor with arrow key grid navigation, Enter to copy, and Escape handling</name>
  <files>Copyhog/Copyhog/Views/PopoverContent.swift</files>
  <action>
**Add state variables:**
1. `@State private var selectedIndex: Int? = nil` — index into `store.displayItems`
2. `@State private var isSearchFocused: Bool = false` — tracks whether search field has focus (Phase 9 will set this to true for hotkey opens; Phase 8 defaults to false on open per user decision)
3. `@State private var eventMonitor: Any? = nil` — reference for cleanup

**Install NSEvent local monitor in `.onAppear`:**
1. Before installing, remove any existing monitor: `if let existing = eventMonitor { NSEvent.removeMonitor(existing) }` (prevents double-install on rapid open/close per Pitfall 4)
2. Install: `eventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in return handleKeyEvent(event) }`
3. Set initial selection to first item: `if !store.displayItems.isEmpty { selectedIndex = 0 }` (user decision: focus lands on first list item, not search field)
4. Set `isSearchFocused = false`

**Remove monitor in `.onDisappear`:**
1. `if let monitor = eventMonitor { NSEvent.removeMonitor(monitor); eventMonitor = nil }`
2. `selectedIndex = nil`
3. `isSearchFocused = false`

**Implement `handleKeyEvent(_ event: NSEvent) -> NSEvent?`:**

When `isSearchFocused == true` (search field has focus):
- **Escape (keyCode 53):** If `!searchText.isEmpty`, clear search: `searchText = ""`, `store.searchQuery = ""`, return nil. If search is empty, call `dismissPopover()`, return nil.
- **Down arrow (keyCode 125):** Set `isSearchFocused = false`. If `selectedIndex == nil` and displayItems is not empty, set `selectedIndex = 0`. Return nil.
- **Tab (keyCode 48):** If `event.modifierFlags.contains(.shift)`, pass through (return event). Otherwise, `isSearchFocused = false`, ensure `selectedIndex` is set, return nil.
- **All other keys:** Return event (let TextField handle them). This implements the user decision: "typing while list is focused = ignore; require Tab to reach search field."

When `isSearchFocused == false` (list has focus):
- **Down arrow (keyCode 125):** Call `handleArrowKey(.down)`, return nil
- **Up arrow (keyCode 126):** Call `handleArrowKey(.up)`, return nil
- **Right arrow (keyCode 124):** Call `handleArrowKey(.right)`, return nil
- **Left arrow (keyCode 123):** Call `handleArrowKey(.left)`, return nil
- **Enter/Return (keyCode 36):** Call `copySelectedItem()`, return nil
- **Escape (keyCode 53):** If `!searchText.isEmpty`, clear search: `searchText = ""`, `store.searchQuery = ""`, reset `selectedIndex = store.displayItems.isEmpty ? nil : 0`, return nil. If empty, call `dismissPopover()`, return nil.
- **Tab (keyCode 48):** Set `isSearchFocused = true`, return nil. (Both Tab and Shift+Tab from list go to search field.)
- **All other keys:** Return event (pass through)

**Implement `handleArrowKey(_ direction:)`:**
Use the 3-column grid layout. `let columns = 3`.
- `.down`: `let next = (selectedIndex ?? -1) + columns`. If `next < store.displayItems.count`, set `selectedIndex = next`. Else do nothing (stop at edge per user decision).
- `.up`: `let next = (selectedIndex ?? 0) - columns`. If `next >= 0`, set `selectedIndex = next`.
- `.right`: `let next = (selectedIndex ?? -1) + 1`. If `next < store.displayItems.count`, set `selectedIndex = next`.
- `.left`: `let next = (selectedIndex ?? 0) - 1`. If `next >= 0`, set `selectedIndex = next`.

**Implement `copySelectedItem()`:**
1. Guard `let index = selectedIndex, index < store.displayItems.count` else return
2. Get `let item = store.displayItems[index]`
3. Guard `let observer = store.clipboardObserver` else return
4. Call `PasteboardWriter.write(item, imageStore: store.imageStore, clipboardObserver: observer)`

**Implement `dismissPopover()`:**
```swift
for window in NSApp.windows where window is NSPanel {
    window.close()
}
```

**Update previewItem computed property:**
Prefer keyboard selection over hover:
```swift
private var previewItem: ClipItem? {
    if let index = selectedIndex, index < store.displayItems.count {
        return store.displayItems[index]
    }
    if let hoveredID = hoveredItemID {
        return store.displayItems.first { $0.id == hoveredID }
    }
    return store.displayItems.first
}
```

**Sync hoveredItemID with selectedIndex:**
When the user moves the mouse and hovers an item, clear `selectedIndex` (or keep it — simpler: just let previewItem priority handle it). Actually, update: when mouse hovers, set `selectedIndex` to the index of the hovered item so the visual selection ring follows the mouse too. This unifies keyboard and mouse selection.

**Reset selectedIndex when searchQuery changes:**
Add `.onChange(of: store.searchQuery)` (or in the existing searchText debounce handler after pushing to store): set `selectedIndex = store.displayItems.isEmpty ? nil : 0`. This prevents Pitfall 2 (stale index after filter changes).

**Wire ScrollViewReader for scroll-to-selection:**
1. Wrap the ScrollView content in `ScrollViewReader { scrollProxy in ... }`
2. Add `.id(item.id)` to each ItemRow
3. Add `.onChange(of: selectedIndex)` that calls `scrollProxy.scrollTo(store.displayItems[selectedIndex].id, anchor: .center)` when selectedIndex changes

**Wire isSelected to ItemRow:**
Update all ItemRow instantiations: `isSelected: store.displayItems.firstIndex(where: { $0.id == item.id }).map { $0 == selectedIndex } ?? false`

Simpler approach: since we iterate with ForEach, and we know the item, just check `isSelected: selectedIndex != nil && store.displayItems.indices.contains(selectedIndex!) && store.displayItems[selectedIndex!].id == item.id`. Even simpler: pass a computed value. Use the item's ID: `isSelected: selectedIndex.flatMap { idx in idx < store.displayItems.count ? store.displayItems[idx].id : nil } == item.id`

**Wire search field focus with `isSearchFocused`:**
Add `.focused()` state or use `.onEditingChanged` on the TextField to sync `isSearchFocused`. The TextField already exists from Plan 01. Add an `onEditingChanged` callback: `TextField("Search history...", text: $searchText, onEditingChanged: { editing in isSearchFocused = editing })`. Note: SwiftUI TextField's `onEditingChanged` fires with `true` when editing begins and `false` when it ends. This provides reliable focus tracking without @FocusState.
  </action>
  <verify>Build the project with `cd Copyhog && xcodebuild -scheme Copyhog -destination 'platform=macOS' build 2>&1 | tail -20`. Verify no compiler errors. Verify `NSEvent.addLocalMonitorForEvents` is present. Verify `handleKeyEvent` handles all required keyCodes (53, 125, 126, 124, 123, 36, 48).</verify>
  <done>
Arrow keys navigate through items in 3-column grid (stop at edges, no wrap). Enter copies selected item to clipboard. Escape clears search text first, dismisses popover on second press. Tab moves focus between search field and item list. Preview pane updates to show keyboard-selected item. Scroll follows selection. On popover open, first list item is selected (not search field). isSearchFocused state exists for Phase 9 hotkey integration (KBNAV-04 infrastructure).
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `cd Copyhog && xcodebuild -scheme Copyhog -destination 'platform=macOS' build`
2. NSEvent local monitor installed on appear, removed on disappear
3. Arrow keys move selection through 3-column grid, stopping at edges
4. Enter copies the selected item via PasteboardWriter
5. Escape clears search text first; second Escape dismisses popover
6. Tab moves focus to search field; Tab/Shift+Tab from search moves to list
7. Preview pane updates when arrowing through items
8. ScrollViewReader scrolls to keep selected item visible
9. On popover open, first item is selected (not search field)
10. isSearchFocused state exists for Phase 9 to set on hotkey open
</verification>

<success_criteria>
- KBNAV-01: Arrow keys move selection through popover items in 3-column grid
- KBNAV-02: Enter on selected item copies it to clipboard
- KBNAV-03: Escape dismisses popover (clears search first if present)
- KBNAV-04: isSearchFocused infrastructure built; Phase 8 opens with list focus, Phase 9 can set isSearchFocused=true for hotkey opens
</success_criteria>

<output>
After completion, create `.planning/phases/08-search-keyboard-navigation/08-02-SUMMARY.md`
</output>
